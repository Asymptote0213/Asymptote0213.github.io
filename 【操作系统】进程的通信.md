# 【操作系统】进程的通信（1）——管道通信

[TOC]



------

## 前言

该篇是该系列【进程通信方式】的第一篇博客。由于不同的进程运行在各自不同的内存空间中．一方对于[变量](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%8F%98%E9%87%8F)的修改另一方是无法感知的．因此．进程之间的信息传递不可能通过变量或其它[数据结构](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)直接进行，只能通过[进程间通信](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)来完成。以下是几种常见的进程通信。

![](D:\Myblog\source\typora-user-images\image-20241018154442231.png)



------



## 一：进程通信的本质

进程间通信（Interprocess communication 也叫IPC）：指两个或多个进程之间进行数据交互的过程。

进程之间可以通过信息交换的方式通信。根据信息交换的方式不同，可以将进程通信分为：

- 共享存储

- 信息传递

- 管道通信

  

## 二：进程通信的方式

### 2.1进程通信——管道

#### 2.1.1什么是管道

- 进程间的通信(IPC-Inter-Process Communication)有多种方式，管道是其中最基本的方式。
- 管道是`半双工`的，即是`单向`的。
- 管道是FIFO(先进先出)的。
- 在实际的多进程间通信时，可以理解为有一条管道，而每个进程都有两个可以使用管道的"端口"，分别负责进行数据的读取与发送。

![](D:\Myblog\source\typora-user-images\image-20241018150929296.png)

> [!NOTE]
>
> （1）「ps -aufx」是查看进程，「grep」命令是过滤文本，后面跟上要筛选的文本，而中间的「｜」就被称为管道。就像是一根管子，前面的命令的输出经过这跟管子传递给后面命令的输入。
>
> ![](D:\Myblog\source\typora-user-images\image-20241018195507653.png)
>
> （2）管道只能单向传输数据，想要实现进程之间的双向传输则需要创建两个管道。
>
> ![](D:\Myblog\source\typora-user-images\image-20241018195548211.png)



#### 2.1.2匿名管道

##### 2.1.2.1匿名管道创建

- 在Linux中，可以使用系统调用接口`pipe()`来创建匿名管道。其函数原型为：`#include <unistd.h> int pipe(int pipefd[2]);`
- `pipefd`是一个输出型参数，是一个包含两个整数的数组。`pipefd[0]`用于读取数据，`pipefd[1]`用于写入数据。
- 调用`pipe()`函数成功后，会返回0，并在`pipefd`数组中填充两个文件描述符，分别指向管道的读端和写端。如果调用失败，则返回-1。

以下代码展示了如何在父子进程间使用匿名管道进行通信：

```
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
#include <unistd.h>  
#include <sys/types.h>  
#include <sys/wait.h>  
  
int main() {  
    int fds[2];  
    pipe(fds); // 创建匿名管道  
  
    pid_t pid = fork();  
    if (pid == 0) { // 子进程  
        close(fds[0]); // 关闭读端  
        char msg[] = "Hello from child process!";  
        write(fds[1], msg, strlen(msg) + 1); // 向管道写入数据  
        close(fds[1]); // 关闭写端  
        exit(0);  
    } else { // 父进程  
        close(fds[1]); // 关闭写端  
        char buffer[1024];  
        ssize_t n = read(fds[0], buffer, sizeof(buffer) - 1); // 从管道读取数据  
        buffer[n] = '\0';  
        printf("Received message: %s\n", buffer);  
        close(fds[0]); // 关闭读端  
  
        // 等待子进程结束  
        int status;  
        waitpid(pid, &status, 0);  
    }  
  
    return 0;  
}
```

##### 2.1.2.2匿名管道通信过程

![](D:\Myblog\source\typora-user-images\image-20241018163012184.png)

##### 2.1.2.3匿名管道的特点

1. 只能单向通信，且只能为存在血缘关系的进程

2. 依赖于文件系统

3. 生命周期跟随进程，在内存中，进程结束后被释放

4. 管道自带同步机制 -- 自带访问控制。

5. 管道是面向字节流的，没有格式边界，需要用户来自定义区分内容的边界。

6. 管道的生命周期，随进程退出而退出。

   

   > [!IMPORTANT]
   >
   > ⭕️ 如果想利用匿名管道实现双向通信，则需要创建两个管道，且需要继承两个管道的文件描述符。
   >
   > ⭕️必须正确关闭不使用的管道端，以避免死锁或者资源泄露。

   

#### 2.1.3命名管道FIFO——先进先出(First-In-First-Out)

匿名管道中，只有血缘关系的进程才可以进程通信，命名管道(FIFO)解决了这个问题。

它提供**一个路径名**与之关联，以文件的形式存储在文件系统。即使进程与创建 FIFO 的进程不存在亲缘关系，只要可以访问该路径，就能够通过 FIFO 相互通信。

##### 2.1.3.1命名管道的创建

- 使用`mkfifo`来来系统调用或命令`mkfifo`来创建一个命名管道。

- 命名管道存在于文件系统中，创建后会作为一个特殊文件出现在指定的路径。

  ```
  #include<sys/types.h>
  #include<sys/stat.h>
  
  int mkfifo(const char *pathname,mode_t moda);
  //pathname:管道的路径名
  //mode:文件的权限
  ```

##### 2.1.3.2命名管道的通信过程

- 写入进程（service）：打开管道的写端，使用write（）写入数据
- 读取进程（client）：打开管道的读端，使用read（）读取数据
- 通信结束：进程关闭管道文件描述符

##### 2.1.3.3命名管道的通信进程

以下程序表示server不断地读入client进程写入的数据

service进程如下：

```
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>

#define PipName "MyFifo"


int main(){
	char buffer[100];
	umask(0);
	if(mkfifo(PipName,0666)<0)
	{
		fprintf(stderr,"mkfifo falied!\n");
		exit(-1);
	}
	printf("waitting for connect with client...\n");
	printf("open success！\n");
	int fd=open(PipName,O_RDONLY);

	if(fd<0)
	{
		fprintf(stderr,"open falied!\n");
		exit(-1);
	}
	while(1)
	{
		buffer[0]='\0';
		ssize_t s=read(fd,buffer,sizeof(buffer-1));
		if(s>0)
		{
			buffer[s]='\0';
			printf("Server read data from [%s],content is %s\n",PipName,buffer);
		}
	}
	close(fd);
	return 0;
}
```

client进程如下：

```
#include<stdio.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include<string.h>

#define PipName "MyFifo"

int main(){
	char msg[100];
	int fd=open(PipName,O_WRONLY);
	if(fd<0)
	{
		fprintf(stderr,"open failed!\n");
		exit(-1);
	}
	while(1)
	{
		printf("please input:");
		fflush(stdout);
		ssize_t s=read(0,msg,sizeof(msg)-1);
		if(s>0)
		{
			msg[s-1]='\0';
			write(fd,msg,strlen(msg));
		}
		else
		{
			printf("read failed/nothing!");
		}
	}
	close(fd);
	return 0;
}
```

首先先编译代码，其次运行server进程（先启动服务），最后运行client进程。

![](D:\Myblog\source\typora-user-images\image-20241018193405358.png)

可以看到生成了一个MyFifo管道，在client端输入数据，可以在server端看到通过管道传输过来的数据。具体流程如下所示：

![](D:\Myblog\source\typora-user-images\151719309484955.png)

> [!CAUTION]
>
> 当服务端没有写入数据的时候，客户端在等。所以，客户端写入之后，服务端才能`read`（会返回）到数据，服务端打印读取数据要以客户端的节奏为主。
>
> 客户端和服务端读写的时候是有一定的顺序性的。 
>  管道内部，没有数据，读端就必须阻塞等待（`read`）。 
>  管道内部，如果数据被写满，写端就必须阻塞等待（`write`）。 
>  阻塞等待时，两个进程会把自己放在管道的等待队列里。
>
> 也就是说，`pipe`内部，**自带访问控制机制**（同步和互斥机制）。 
> 而在两个进程各自`printf`（向显示器写入）时没有顺序，此时缺乏访问控制。

##### 2.1.3.4命名管道的通信特点

1. **命名管道可以实现任意两个进程间的通信。**
2. 管道只能单向通信（内核实现决定的），是半双工的一种特殊情况。
3. 管道自带同步机制 -- 自带访问控制。
4. 管道是面向字节流的，没有格式边界，需要用户来自定义区分内容的边界。
5. 管道的生命周期，随进程退出而退出。

###      2.1.4匿名管道和命名管道的区别

![](D:\Myblog\source\typora-user-images\image-20241018173507883.png)

