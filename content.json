{"meta":{"title":"Asymptote","subtitle":"","description":"哈哈哈哈哈哈哈","author":"Asymptote0213","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2024-10-14T10:04:29.000Z","updated":"2024-10-17T08:42:49.576Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-10-14T10:04:05.000Z","updated":"2024-10-14T10:07:43.709Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-10-17T08:44:38.000Z","updated":"2024-10-17T08:45:50.823Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"【Android Studio】学习之Service组件","date":"2024-10-17T03:07:28.796Z","updated":"2024-10-17T03:07:28.796Z","comments":true,"path":"posts/undefined.html","permalink":"http://example.com/posts/undefined.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Android Studio——ActivityResultLauncher","slug":"【Android Studio】ActivityResultLauncher","date":"2024-10-14T02:24:10.640Z","updated":"2024-10-17T03:28:28.042Z","comments":true,"path":"posts/undefined.html","permalink":"http://example.com/posts/undefined.html","excerpt":"","text":"【Android Studio】ActivityResultLauncher[TOC] 一：什么是ActivityResultLauncherActivityResultLauncher是Android Studio用于在应用程序中启动活动并接收其结果的组件，它是startActivityForResult的改进版本。 优点： 类型安全：结果处理逻辑和启动器绑定在一起，避免传统方法中可能出现的类型转换错误。 解耦：不需要重写onActivityResult（），逻辑更加清晰。 生命周期感知：启动器与生命周期相关联，在适当的时间注册和取消注册。 二：ActivityResultLauncherActivityResultLauncher 是一个用于简化 Android 开发中 startActivityForResult 流程的新 API。它通过注册 contract 和 ActivityResultCallback 来启动和接收活动结果，提供更直观的流程管理。ActivityResultLauncher 是 Android 官方推荐的用来替代 startActivityForResult 的新方式，通过它可以非常方便地调用系统 Intent 进行拍照、选取本地文件等操作。 三：活动之间互相传递数据【目的】创建两个Activity文件实现点击按钮互相在页面上显示数据。 3.1向下一个Activity传递数据前置要求： 设置layout的布局： ActivityA_layout: 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/pushtoA&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center|center_horizontal&quot; android:text=&quot;@string/page4&quot; android:textSize=&quot;34sp&quot; /&gt; &lt;Button android:id=&quot;@+id/ButtonToA&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;124dp&quot; B_layout: android:gravity=&quot;center&quot; android:text=&quot;@string/Button4&quot; android:textSize=&quot;34sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/viewB&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/view2&quot; android:textSize=&quot;34sp&quot; /&gt;&lt;/LinearLayout&gt; ActivityB_layout: 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/pushtoB&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center|center_horizontal&quot; android:text=&quot;@string/page3&quot; android:textSize=&quot;34sp&quot; /&gt; &lt;Button android:id=&quot;@+id/ButtonToB&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;124dp&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/Button3&quot; android:textSize=&quot;34sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/viewA&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/view1&quot; android:textSize=&quot;34sp&quot; /&gt;&lt;/LinearLayout&gt; 向下一个活动传递数据，通过Intent类，此处我们使用点击Button触发，在下一个页面显示信息。 新建Activity3页面，在Activity文件中创建一个Intent的对象，传入上下文，和下一个活动的.class 在Activity4页面，写入以下内容： 运行结果： ActivityA界面： 点击button显示： 显示成功！ 3.2向上一个Activity传递数据如何实现点击B的按钮再跳转A?并且传值使用launcher，因为这样A就能根据id号来准确判断分别来自于哪个页面的button值 （1）首先在ActivityA中设置ActivityResultLauncher： 首先，你需要在FirstActivity中定义一个ActivityResultLauncher。这通常是在你的Activity的onCreate方法中完成的。 12345678910111213141516// ActivityA.java private ActivityResultLauncher&lt;Intent&gt; someActivityResultLauncher = registerForActivityResult( new ActivityResultContracts.StartActivityForResult(), new ActivityResult.Callback&lt;ActivityResult&gt;() &#123; @Override public void onActivityResult(ActivityResult result) &#123; if (result.getResultCode() == Activity.RESULT_OK) &#123; Intent data = result.getData(); if (data != null) &#123; String returnedData = data.getStringExtra(&quot;resultKey&quot;); // 处理从SecondActivity返回的数据 &#125; &#125; &#125; &#125; ); 如图： [!NOTE] 注意：ActivityResultContracts.StartActivityForResult()是一个预定义的合同，用于启动一个Activity并期待结果。 （2）**在FirstActivity中启动SecondActivity**：使用你定义的ActivityResultLauncher来启动SecondActivity。 （3）在SecondActivity中设置结果数据并返回： 在SecondActivity中，当用户点击按钮时，你需要创建一个Intent来携带返回数据，并调用setResult方法来结束SecondActivity并返回数据。 1234567891011// ActivityB.java Button returnButton = findViewById(R.id.return_button); returnButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent returnIntent = new Intent(); returnIntent.putExtra(&quot;resultKey&quot;, &quot;这是从SecondActivity传递回的数据&quot;); setResult(Activity.RESULT_OK, returnIntent); finish(); // 结束SecondActivity &#125; &#125;); 按照以上格式写我们自己的代码如下： 运行结果（从B点击按钮跳转A） 跳转成功！ 现在，当用户从SecondActivity点击按钮时，SecondActivity会结束，并且携带的数据会通过ActivityResultLauncher的回调方法返回给FirstActivity。 四：总结这种方法的好处是，它使用了Android Jetpack中的ActivityResultAPIs，这些API旨在简化Activity之间的结果传递，并处理一些与请求代码和结果代码相关的常见错误。此外，使用ActivityResultLauncher还可以避免内存泄漏，因为它不需要你在Activity中显式地覆盖onActivityResult方法。 最后，推荐一个关于ActivityResultlauncher深入学校的博客： https://github.com/SheTieJun/BaseKit/wiki/ActivityResultLauncher%E4%BD%BF%E7%94%A8","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-10-11T14:59:27.617Z","updated":"2024-10-11T14:59:27.617Z","comments":true,"path":"posts/undefined.html","permalink":"http://example.com/posts/undefined.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Android Studio——Activity组件","slug":"Android Studio学习之Activity组件","date":"2024-10-11T14:53:57.784Z","updated":"2024-10-14T10:46:54.697Z","comments":true,"path":"posts/undefined.html","permalink":"http://example.com/posts/undefined.html","excerpt":"","text":"Android Studio学习之Activity组件实验报告实验目标： 1、掌握Activity的注册； 2、掌握Activity的生命周期； 3、掌握Intent，实现Activity之间的跳转； 4、请设计实验验证Activity的生命周期；请设计实验验证跳转时Activity生命周期的状态变化 [TOC] 一：Activity的原理1.1Activity是安卓系统中负责用户可视化界面交互的关键组件，称为活动组件（也称为界面程序），它会加载布局文件（属于资源文件）例如 setContentView(R.layout.activity_main) 二：Activity的基本用法2.1创建Activity文件点击 Empty Activity 创建名为 FirstActivity 的 Activity 新建一个Activity文件 2.2 创建布局和加载布局右键 app&#x2F;src&#x2F;main&#x2F;res 目录-&gt;New-&gt;Directory，会弹出一个新建目录的窗口，现在这里创建一个名为 layout 的目录，然后对着 layout 目录右键-&gt;New-&gt;Layout resource file，优惠弹出一个新建布局资源文件的窗口，我们将这个布局文件命名为first_layout，根元素默认选择为 LinearLayout。 可以点击预览窗口看到对应的代码 2.2.1在布局中添加按钮，如图 2.2.2 加载布局文件项目中每添加一个元素都会在 R 文件中响应的生成一个资源 id，因此刚才添加的布局文件的 id 就已经添加到了 R 文件中，所以可以通过R.layout.first_layout找到 first_layout.xml 的 id，然后将这个值传入到 setContentView() 方法即可。 2.3 在 AndoirdManifest.xml 文件中注册 [!NOTE] 如何找到AndroidManifest.xml文件： 在Project目录下，在项目结构面板中，展开app文件夹，找到src&#x2F;main目录找到AndroidManifest.xml文件 可以看到，Activity 的注册声明要放在 &lt;application&gt; 标签中，这里通过 &lt;activity&gt; 标签来对 Activity 进行注册。在&lt;activity&gt;中通过 name 属性指定具体注册哪一个 Activity，那么这里填入 .FirstActivity ，前面加 “.” 是因为最外层已经声明了 package 属性，在 name 的地方添加.FirstActivity 即可通过全类名找到 FirstActivity。 此时已经注册了Activity,但是还不能运行程序，因为需要配置 Activity，也就是说需要指定最先启动哪个 Activity。所以需要在 &lt;activity&gt; 标签中添加 intent-filter 标签，然后在 intent-filter 标签中添加 &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; 和 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; 两行声明即可。 这样操作之后，FirstActivity 就成了这个应用的主 Activity 了，点击应用图标最先打开的就是这个 Activity。但是如果没有在应用中声明任何一个 Activity 作为主 Activity，这个程序依然是可以安装的，只是无法在启动器中看到这个应用程序。这种程序通常作为第三方服务供其它应用在内部进行调用。运行成功！ 三.使用 Intent 在 Activity 之间穿梭Intent 是 Android 中各组件之间进行交互的一种重要方式，它不仅可以置名当前组件想执行的动作，还可以在不同的组件之间传递数据。Intent 一般可用于启动 Activity、启动 Service以及发送广播等场景。Intent 大致分为两种：显式和隐式。 3.1使用显式的Intent3.1.1创建SecondActivity并修改布局，如下图所示： 3.1.2修改FirstActivity文件内容： 3.1.3运行虚拟机完成跳转 四：Activity的生命周期4.1Activity的生命周期Activity的生命周期是指Activity从创建到销毁的过程。Android 是使用任务来管理 Activity 的，一个任务就是一组存放在栈里的 Activity 的集合，这个栈也被称为返回栈（back stack）。栈是一种后进先出的数据结构，在默认情况下，每当我们启动新的 Activity，它就会在返回栈中入栈，并处于栈顶的位置。而每当我们按下 Back 键或调用 finish() 方法后，处于栈顶的 Activity 就会出栈，前一个入栈的 Activity 就会重新处在栈顶的位置，下图展示了返回栈如何管理 Activity 入栈出栈操作。 4.2Activity的状态（1）活动状态——Active：Activity在用户界面中处于最上层（处于栈顶），完全被用户看到，且能与用户进行交互。 （2）暂停状态——Pause：Activity在界面上被部分遮挡，不再处于最上层（ 不再处于栈顶的位置，但仍然可见），且不能和用户进行交互。（如弹出消息框） （3）停止状态——Stop：Activity被其他Activity全部遮挡，界面完全被用户看不见，当其它地方需要内存时，处于停止状态的 Activity 有可能会被系统回收。。（如玩游戏时来电显示） （4）非活动状态——Dead：从返回栈中移除后就变成了销毁状态，Activity没有被启动或者被finish（）。 4.3Activity的生存期Activity 类中定义了7个回调方法，覆盖了 Activity 生命周期的每一个环节。 4.4Activity生命周期的验证实验新建一个Activity,并写入以下代码，如图所示： 点击运行键运行虚拟机，打开Android Studio右下方的logcat，就可以看到代码运行的log日志，如下所示： （1）点击run后虚拟机运行成功且出现Activity窗口时，logcat的显示： （2）按下主屏幕键，再按下任务视图，点击还原该窗口时，logcat的显示： （3）按下退出键，Activity结束，logcat显示： 这样一个程序的生命周期就完成啦！^-^ 4.5验证页面跳转时的生命周期变化利用上面的FirstActivity和SecondActivity完成该实验的验证。 在FirstActivity.java和SecondActivity.java文件中分别写入生命周期的函数。（此处不一一展示，和上面的单个程序的生命周期布局相同）运行APP，在logcat中查看生命周期。 点击运行键，过程如下所示： （1）首先启动FirstActivity,查看： （2）然后点击FirstActivity的跳转按钮： （3）点击SecondActivity的返回按钮回到上一界面： （4）关闭程序： 可以看到（绿框部分）：FirstActivity先onPause了，SecondActivity执行了onCreate,当SecondActivity的onResume执行了，FirstActivity才stop,这个是不是和我们经常看的activity的生命周期是一样的。由此得到了验证。 总结：耗时两天终于搞懂了Activity的大致用法。昨日之深渊，今日之浅潭。路虽远行则将至，事虽难做则可成。共勉！","categories":[],"tags":[]}],"categories":[],"tags":[]}